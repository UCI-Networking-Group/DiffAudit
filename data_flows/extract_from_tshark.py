#!/usr/bin/python

# This file is a part of DiffAudit <https://athinagroup.eng.uci.edu/projects/childrens-privacy/>.
# Copyright (c) 2024 UCI Networking Group.
#
# This file incorporates content from OVRseen <https://athinagroup.eng.uci.edu/projects/ovrseen/>.
# Copyright (c) 2021 UCI Networking Group.
#
# DiffAudit is dual licensed under the MIT License and the GNU General Public
# License version 3 (GPLv3). This file is covered by the GPLv3. If this file
# get used, GPLv3 applies to all of DiffAudit.
#
# See the LICENSE.md file along with DiffAudit for more details.

'''
Script used to extract only the needed information from JSON packet traces generated by tshark from PCAPNG format
'''

import os
import json
import uuid
import argparse
from convert_har import extract_kv_pairs
from collections import OrderedDict
import tldextract
from utils import utils

# set of tuples (src port, dst IP) of decrypted connections
decrypted_tuples = set()

def make_unique(key, dct):
    counter = 0
    unique_key = key

    while unique_key in dct:
        counter += 1
        unique_key = key + "_" + str(counter)
    return unique_key


def parse_object_pairs(pairs):
    dct = OrderedDict()
    for key, value in pairs:
        if key in dct:
            key = make_unique(key, dct)
        dct[key] = value

    return dct


def get_tcp_stream_number(pkt):
    '''
    Extract the TCP stream id/number assigned to this packet by tshark.
    :param pkt: A packet in tshark json format.
    :return: The TCP stream id/number assigned by tshark to this packet, or None if the value is not present in the
             packet, e.g., the packet is not a TCP segment.
    '''
    layers = pkt[utils.source][utils.layers]
    if utils.tcp not in layers:
        return None
    tcp_section = layers[utils.tcp]
    if utils.tcpstream not in tcp_section:
        return None
    return int(tcp_section[utils.tcpstream])


def extract_http_pkt(layers, frame_num, httpv, include_http_body=True):
    '''
    Extract HTTP information from tshark json to NoMoAds json.
    :param layers: a packet data from the _source.layers structure in tshark json format.
    :param frame_num: a string containing the frame number (for std.out warnings in case something unexpected happens)
    :return: A map that contains the interesting HTTP data
    '''

    # Go through all HTTP fields and extract the ones that are needed
    if httpv == 1:
        json_http_key = utils.http
        json_http_req = utils.http_req
        json_http_req_method = utils.http_req_method
        json_http_req_uri = utils.http_req_uri
        json_http_req_line = utils.http_req_line
        json_http_body = utils.http_body
    elif httpv == 2:
        json_http_key = utils.http2
        json_http_req = utils.http2_req
        json_http_req_method = utils.http2_req_method
        json_http_req_uri = utils.http2_req_uri
        json_http_req_line = utils.http2_req_line
        json_http_body = utils.http2_body

    http_data = layers[json_http_key]
    new_packet, kv_dict = {}, {}
    all_kvs = []

    # Prepare container for HTTP headers
    if httpv == 1:
        if utils.headers not in new_packet:
            new_packet[utils.headers] = {}
    elif httpv == 2:
        new_packet[utils.headers] = {}
        ## http2 has different header structure
        count = 0
        if utils.http2_header_count in http_data[utils.http2_stream]:
            temp_headers = {}
            for i in range(int(http_data[utils.http2_stream][utils.http2_header_count])):
                if i == 0:
                    key_name = utils.http2_header_first
                else:
                    key_name = utils.http2_header_num + str(i)

                if http_data[utils.http2_stream][key_name][utils.http2_header_name] in temp_headers.keys():
                    temp_headers[http_data[utils.http2_stream][key_name][utils.http2_header_name] + str(count)] = http_data[utils.http2_stream][key_name][utils.http2_header_value]
                    count += 1
                else:    
                    temp_headers[http_data[utils.http2_stream][key_name][utils.http2_header_name]] = http_data[utils.http2_stream][key_name][utils.http2_header_value]
            new_packet[utils.headers] = temp_headers
        
            for key in temp_headers.keys():
                if utils.http2_auth_host in key:
                    new_packet[utils.host] = temp_headers[key]
                
                elif utils.method in key:
                    new_packet[utils.method] = temp_headers[key]

    # Go through other keys of interest
    for http_key in http_data:
        http_value = http_data[http_key]

        if http_key.startswith(json_http_req_line):
            header_line = http_value.split(":", 1)
            if len(header_line) != 2:
                print("WARNING: could not parse header '" + str(header_line) + "'"
                      + frame_num)
                continue

            # Use lower case for header keys to stay consistent with our other data
            header_key = header_line[0].lower()

            # Remove the trailing carriage return
            header_val = header_line[1].strip()

            # Save the header key-value pair
            new_packet[utils.headers][header_key] = header_val

            # If this is the host header, we also save it to the main object
            if header_key == utils.host:
                if header_val.endswith('443'):
                    header_val = header_val[:-3]
                new_packet[utils.host] = header_val
                
        if json_http_req_method in http_value:
            new_packet[utils.method] = http_value[json_http_req_method]
        
        if json_http_req_uri in http_value:
            new_packet[utils.uri] = http_value[json_http_req_uri]
            # Extract key-values pairs data from url request
            kv_dict[utils.extracted_kvs_url] = extract_kv_pairs(str(http_value[json_http_req_uri])) 
            all_kvs += kv_dict[utils.extracted_kvs_url]

    # Note that packet was http
    new_packet[utils.protocol] = json_http_key

    if len(new_packet[utils.headers].keys()) == 0 and httpv == 1:
        print("WARNING: packet has no header: ", str(http_data))
    else:
        kv_dict[utils.extracted_kvs_header] = extract_kv_pairs(json.dumps(new_packet[utils.headers]))
        all_kvs += kv_dict[utils.extracted_kvs_header]

    # If there is a body, extract key-value pairs
    if json_http_body in http_data:
        new_packet[json_http_body] = http_data[json_http_body]
        kv_dict[utils.extracted_kvs_payload] = extract_kv_pairs(str(http_data[json_http_body])) # Extract key-values pairs data from payload data
        all_kvs += kv_dict[utils.extracted_kvs_payload]

    # Merge all three kvs pairs sources together
    kv_dict[utils.all_extracted_kvs] = all_kvs

    return new_packet, kv_dict


def extract_tls_pkt(layers):
    '''
    Extract TLS information from tshark json to NoMoAds json.
    :param layers: a packet data from the _source.layers structure in tshark json format.
    :return: A map that contains the interesting TLS data
    '''

    ssl_layer = layers[utils.ssl]
    ssl_record_key = utils.ssl + ".record"
    ssl_handshake_key = utils.ssl + ".handshake"
    if ssl_record_key not in ssl_layer or ssl_handshake_key not in ssl_layer[ssl_record_key]:
        return None

    handshake = ssl_layer[ssl_record_key][ssl_handshake_key]
    for key in handshake:
        if key.startswith("Extension: server_name"):
            # Carries the server name extension, see if we can find SNI
            srv_name_ext = handshake[key]
            # SNI is an object with properties
            sni_ext_obj_key = "Server Name Indication extension"
            if sni_ext_obj_key not in srv_name_ext:
                # SNI not present
                return None
            sni_ext_obj = srv_name_ext[sni_ext_obj_key]
            srv_name_key = ssl_handshake_key + ".extensions_server_name"
            if srv_name_key not in sni_ext_obj:
                return None
            # Found SNI, so create a new packet and return it to caller
            new_packet = {}
            # We put the value of the SNI in the host field as that is the host the client is talking to.
            new_packet[utils.host] = sni_ext_obj[srv_name_key]
            # Note that packet was TLS
            new_packet[utils.protocol] = utils.ssl
            return new_packet

    # Not a Client Hello handshake packet, or a handshake packet w/o SNI.
    return None


def extract_other_pkt(layers, frame_num, include_http_body=False):
    '''
    Extract JSON-structured information in other packets from tshark json to NoMoAds json.
    :param layers: a packet data from the _source.layers structure in tshark json format.
    :param frame_num: a string containing the frame number (for std.out warnings in case something unexpected happens)
    :return: A map that contains the interesting JSON data
    '''
    # Get what we need from the packet
    new_packet = {}
    all_kvs = []

    # Check if this is a websocket packet
    if utils.websocket in layers and utils.websocketdata in layers:
        # Note that packet was websocket
        new_packet[utils.protocol] = utils.websocket
        # Extract PII from data
        json_data = json.dumps(layers[utils.websocketdata])
    else:
        # Note that packet was irc
        new_packet[utils.protocol] = utils.irc
        # Extract PII from data
        json_data = json.dumps(layers[utils.irc])

    new_packet[utils.http_body] = json_data
    all_kvs += extract_kv_pairs(str(json_data))

    return new_packet, all_kvs


def extract_from_tshark(full_path, data, extracted_kvs_dict, is_decrypted, include_http_body=False):
    with open(full_path, "r") as jf:
        # Since certain json 'keys' appear multiple times in our data, we have to make them
        # unique first (we can't use regular json.load() or we lose some data points). From:
        # https://stackoverflow.com/questions/29321677/python-json-parser-allow-duplicate-keys
        decoder = json.JSONDecoder(object_pairs_hook=parse_object_pairs)
        pcap_data = decoder.decode(jf.read())

        for packet in pcap_data:
            kv_dict = {}

            layers = packet[utils.source][utils.layers]

            # All captured traffic should have a frame + frame number, but check anyway
            frame_num = " Frame: "
            if utils.frame not in layers or utils.frame_num not in layers[utils.frame]:
                print("WARNING: could not find frame number! Using -1...")
                frame_num = frame_num + "-1"
            else:
                # Save frame number for error-reporting
                frame_num = frame_num + layers[utils.frame][utils.frame_num]

            # All captured traffic should be IP, but check anyway
            if not utils.ip in layers:
                print("WARNING: Non-IP traffic detected!" + frame_num)
                continue

            # For now we only care about outgoing traffic
            src_ip = layers[utils.ip][utils.ip + ".src"]
            dst_ip = layers[utils.ip][utils.ip + ".dst"]
            if src_ip != utils.PCAPDROID_SRC_IP:
                continue

            # For now, only care about TCP traffic
            if not utils.tcp in layers:
                continue

            src_port = int(layers[utils.tcp][utils.tcp + ".srcport"])
            dst_port = int(layers[utils.tcp][utils.tcp + ".dstport"])

            # Perform initialization of new_packet in application layer protocol data extraction functions:
            # Attempt to extract application layer protocol information for each of the protocols that we are interested
            # in until we successfully hit the protocol (or declare that the packet is not interesting if no match).
            new_packet = None

            # Check if HTTP first
            if utils.http in layers:
                httpv = 1
                new_packet, kv_dict = extract_http_pkt(layers, frame_num, httpv, include_http_body=include_http_body)
                # Keep track of decrypted connections by source port and destination IP to avoid double-counting
                if is_decrypted:
                    decrypted_tuples.add((src_port, dst_ip))

            elif utils.http2 in layers:
                httpv = 2
                new_packet, kv_dict = extract_http_pkt(layers, frame_num, httpv, include_http_body=include_http_body)
                # Keep track of decrypted connections by source port and destination IP to avoid double-counting
                if is_decrypted:
                    decrypted_tuples.add((src_port, dst_ip))
            
            # Not HTTP, so try TLS as those may carry the hostname of the server in the SNI.
            # We skip SNI for flows which were decrypted and where we got the host name from HTTP headers
            # NOTE: we still save SNI for non-HTTP flows that were decrypted as those do not contain a host field
            elif utils.ssl in layers and (src_port, dst_ip) not in decrypted_tuples:
                new_packet = extract_tls_pkt(layers)
            
            else:
                # Packet not HTTP, so it's not interesting to us.
                # Some TLS packets still go here, so skip these as well.
                if not utils.ssl in layers:
                    # We are interested in websocket and irc packets.
                    if utils.websocket in layers and utils.websocketdata in layers:
                        new_packet, kvs_arr = extract_other_pkt(layers, frame_num, include_http_body=include_http_body)
                        kv_dict[utils.all_extracted_kvs] += kvs_arr
                    if utils.irc in layers:
                        new_packet, kvs_arr = extract_other_pkt(layers, frame_num, include_http_body=include_http_body)
                        kv_dict[utils.all_extracted_kvs] += kvs_arr
                else:
                    continue

            if new_packet is None or kv_dict == {}:
                new_packet = {}
                ## don't skip - we still want to get src and destination 

            # Fill our new JSON packet with TCP/IP info and other common info
            new_packet[utils.src_ip] = src_ip
            new_packet[utils.dst_ip] = dst_ip
            new_packet[utils.dst_port] = dst_port

            # Extract the tcp stream id/number, if any
            tcp_stream_id = get_tcp_stream_number(packet)
            if tcp_stream_id is not None:
                new_packet[utils.tcpstream] = tcp_stream_id

            # Extract timestamp
            if utils.frame_ts not in layers[utils.frame]:
                print("WARNING: could not find timestamp!" + frame_num)
                continue

            new_packet["ts"] = layers[utils.frame][utils.frame_ts]

            # Create a unique key for each packet to keep consistent with ReCon
            # Also good in case packets end up in different files
            uid = str(uuid.uuid4()) 
            data[uid] = new_packet
            extracted_kvs_dict[uid] = kv_dict

    host_dict = {}
    for k, v in data.items():
        if utils.host in v.keys():
            if v[utils.dst_ip] in host_dict.keys():
                if host_dict[v[utils.dst_ip]] != v[utils.host]:
                    opt1 = tldextract.extract( v[utils.host])
                    opt2 = tldextract.extract( host_dict[v[utils.dst_ip]])
                    sld1 = opt1.domain + "." + opt1.suffix
                    sld2 = opt2.domain + "." + opt2.suffix
                    if sld1 == sld2:
                        host_dict[v[utils.dst_ip]] = sld1
                    else:
                        print("Warning: Cannot figure hostname for this packet.")
                        host_dict[v[utils.dst_ip]] = ""
            else:
                host_dict[v[utils.dst_ip]] = v[utils.host]

    for k, v in data.items():
        if utils.host not in v.keys(): # no hostname in packet, then add the sld from existing packets
            if v[utils.dst_ip] in host_dict.keys():
                data[k][utils.host] = host_dict[v[utils.dst_ip]]

    return data, extracted_kvs_dict


def write_data(data, file_out, permission):
    # Write the new data
    with open(file_out, permission) as jf:
        jf.seek(0)
        jf.write(json.dumps(data, sort_keys=True, indent=4))
        jf.truncate()


def extract(tshark_file_enc, tshark_file_dec, nomoads_out_file, kvs_out_file, **kwargs):
    """
    Extracts only the needed information from provided JSON packet traces and labels them
    :param tshark_file: JSON file containing data extracted via tshark
    :param out_file: File to write results to
    :return: True on success, False on failure
    """

    if not (os.path.isfile(tshark_file_enc) or os.path.isfile(tshark_file_dec)):
        print("ERROR: invalid argument")
        return False

    # Prepare new data structure for re-formatted JSON storage
    data, extracted_kvs_dict = {}, {}

    # Extract decrypted data first to know which connections were successfully decrypted
    data, extracted_kvs_dict = extract_from_tshark(tshark_file_dec, data, extracted_kvs_dict, True, **kwargs)

    ## Extract encrypted data next
    data, extracted_kvs_dict = extract_from_tshark(tshark_file_enc, data, extracted_kvs_dict, False, **kwargs)

    ## write nomoads json file
    write_data(data, nomoads_out_file, "w")

    ## write outputs kvs data
    write_data(extracted_kvs_dict, kvs_out_file, "w")

    return True


if __name__ == '__main__':
    ap = argparse.ArgumentParser(description="Converts tshark JSON output into NoMoAds JSON format")
    ap.add_argument('--enc_file', required=False, help='Encrypted pcap')
    ap.add_argument('--dec_file', required=True, help='Decrypted pcap')
    ap.add_argument('--nomoads_out_file', required=True, help='Output file for nomoads json')
    ap.add_argument('--kvs_out_file', required=True, help='Output file for extracted kvs')
    ap.add_argument('--include_http_body', action="store_true", help='Whether to include http body')
    args = ap.parse_args()

    extract(args.enc_file, args.dec_file, args.nomoads_out_file, args.kvs_out_file, include_http_body=args.include_http_body)